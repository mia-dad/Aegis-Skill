package com.mia.aegis.skill.executor.store;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 内存实现的执行上下文快照存储。
 *
 * <p>使用 ConcurrentHashMap 实现线程安全的快照存储。</p>
 *
 * <p>适用于单实例部署场景，不支持分布式环境。</p>
 *
 * <p>注意事项：</p>
 * <ul>
 *   <li>重启后数据丢失</li>
 *   <li>无自动过期清理，需外部调用 findExpired + removeById</li>
 *   <li>生产环境建议使用 Redis 或数据库存储</li>
 * </ul>
 *
 * <p>并发安全：</p>
 * <ul>
 *   <li>使用 ConcurrentHashMap 保证基本操作的线程安全</li>
 *   <li>状态转换使用细粒度锁保证原子性</li>
 *   <li>支持 CAS 风格的条件状态更新</li>
 * </ul>
 */
public class InMemoryExecutionStore implements ExecutionStore {

    private static final Logger logger = LoggerFactory.getLogger(InMemoryExecutionStore.class);

    private final ConcurrentMap<String, ExecutionContextSnapshot> store;
    private final ConcurrentMap<String, ReentrantLock> locks;

    /**
     * 创建 InMemoryExecutionStore 实例。
     */
    public InMemoryExecutionStore() {
        this.store = new ConcurrentHashMap<String, ExecutionContextSnapshot>();
        this.locks = new ConcurrentHashMap<String, ReentrantLock>();

        logger.debug("创建 InMemoryExecutionStore");
    }

    @Override
    public void save(ExecutionContextSnapshot snapshot) {
        if (snapshot == null) {
            throw new IllegalArgumentException("snapshot cannot be null");
        }
        if (snapshot.getExecutionId() == null || snapshot.getExecutionId().trim().isEmpty()) {
            throw new IllegalArgumentException("executionId cannot be null or empty");
        }
        store.put(snapshot.getExecutionId(), snapshot);
    }

    @Override
    public ExecutionContextSnapshot findById(String executionId) {
        if (executionId == null || executionId.trim().isEmpty()) {
            return null;
        }
        return store.get(executionId);
    }

    @Override
    public ExecutionContextSnapshot removeById(String executionId) {
        if (executionId == null || executionId.trim().isEmpty()) {
            return null;
        }
        locks.remove(executionId);
        return store.remove(executionId);
    }

    @Override
    public List<ExecutionContextSnapshot> findExpired(long beforeTimestamp) {
        List<ExecutionContextSnapshot> expired = new ArrayList<ExecutionContextSnapshot>();
        for (ExecutionContextSnapshot snapshot : store.values()) {
            if (snapshot.getCreatedAt() < beforeTimestamp &&
                snapshot.getStatus() == SnapshotStatus.ACTIVE) {
                expired.add(snapshot);
            }
        }
        return expired;
    }

    @Override
    public boolean updateStatus(String executionId, SnapshotStatus newStatus) {
        if (executionId == null || newStatus == null) {
            return false;
        }

        ReentrantLock lock = getLockFor(executionId);
        lock.lock();
        try {
            ExecutionContextSnapshot snapshot = store.get(executionId);
            if (snapshot != null) {
                snapshot.setStatus(newStatus);
                return true;
            }
            return false;
        } finally {
            lock.unlock();
        }
    }

    /**
     * 原子性地更新状态（仅当当前状态匹配时）。
     *
     * <p>CAS 风格的条件更新，用于防止并发恢复冲突。</p>
     *
     * @param executionId 执行标识符
     * @param expectedStatus 期望的当前状态
     * @param newStatus 新状态
     * @return 是否更新成功
     */
    public boolean compareAndUpdateStatus(String executionId,
                                           SnapshotStatus expectedStatus,
                                           SnapshotStatus newStatus) {
        if (executionId == null || expectedStatus == null || newStatus == null) {
            return false;
        }

        ReentrantLock lock = getLockFor(executionId);
        lock.lock();
        try {
            ExecutionContextSnapshot snapshot = store.get(executionId);
            if (snapshot != null && snapshot.getStatus() == expectedStatus) {
                snapshot.setStatus(newStatus);
                return true;
            }
            return false;
        } finally {
            lock.unlock();
        }
    }

    /**
     * 获取指定快照的锁。
     *
     * <p>使用细粒度锁，每个快照有独立的锁，避免全局锁竞争。</p>
     *
     * @param executionId 执行标识符
     * @return 对应的锁
     */
    private ReentrantLock getLockFor(String executionId) {
        locks.putIfAbsent(executionId, new ReentrantLock());
        return locks.get(executionId);
    }

    @Override
    public boolean exists(String executionId) {
        if (executionId == null || executionId.trim().isEmpty()) {
            return false;
        }
        return store.containsKey(executionId);
    }

    @Override
    public int size() {
        return store.size();
    }

    @Override
    public void clear() {
        store.clear();
        locks.clear();
    }
}
